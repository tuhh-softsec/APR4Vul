<START_VUL> public class SubversionRepositoryStatus extends AbstractModelObject { public final UUID uuid ; public SubversionRepositoryStatus ( UUID uuid ) { this . uuid = uuid ; } public String getDisplayName ( ) { return uuid . toString ( ) ; } public String getSearchUrl ( ) { return uuid . toString ( ) ; } static interface JobProvider { @ SuppressWarnings ( str ) List < Job > getAllJobs ( ) ; } public static abstract class Listener implements ExtensionPoint { public abstract boolean onNotify ( UUID uuid , long revision , Set < String > affectedPaths ) ; } private static Method IS_IGNORE_POST_COMMIT_HOOKS_METHOD ; public void doNotifyCommit ( StaplerRequest req , StaplerResponse rsp ) throws ServletException , IOException { requirePOST ( ) ; Set < String > affectedPath = new HashSet < String > ( ) ; String line ; BufferedReader r = new BufferedReader ( req . getReader ( ) ) ; try { while ( ( line = r . readLine ( ) ) != null ) { if ( LOGGER . isLoggable ( FINER ) ) { LOGGER . finer ( str + line ) ; } affectedPath . add ( line . substring ( num1 ) ) ; if ( line . startsWith ( str ) ) { String msg = str + line ; LOGGER . warning ( msg ) ; throw new IllegalArgumentException ( msg ) ; } } } finally { IOUtils . closeQuietly ( r ) ; } if ( LOGGER . isLoggable ( FINE ) ) LOGGER . fine ( str + uuid + str + affectedPath ) ; QueryParameterMap query = new QueryParameterMap ( req ) ; String revParam = query . get ( str ) ; if ( revParam == null ) { revParam = req . getHeader ( str ) ; } long rev = - num2 ; if ( revParam != null ) { rev = Long . parseLong ( revParam ) ; } boolean listenerDidSomething = false ; for ( Listener listener : ExtensionList . lookup ( Listener . class ) ) { try { if ( listener . onNotify ( uuid , rev , affectedPath ) ) { listenerDidSomething = true ; } } catch ( Throwable t ) { LOGGER . log ( WARNING , str + listener . getClass ( ) . getName ( ) + str , t ) ; } } if ( ! listenerDidSomething ) LOGGER . log ( Level . WARNING , str , uuid ) ; rsp . setStatus ( SC_OK ) ; } private static class SubversionRepoUUIDAndRootPath { public final UUID uuid ; public final String rootPath ; public SubversionRepoUUIDAndRootPath ( UUID uuid , String rootPath ) { this . uuid = uuid ; this . rootPath = rootPath ; } } @ Extension public static class JobTriggerListenerImpl extends Listener { private Map < String , UUID > remoteUUIDCache = new HashMap < String , UUID > ( ) ; private JobProvider jobProvider = new JobProvider ( ) { @ SuppressWarnings ( str ) public List < Job > getAllJobs ( ) { return Jenkins . getInstance ( ) . getAllItems ( Job . class ) ; } } ; void setJobProvider ( JobProvider jobProvider ) { this . jobProvider = jobProvider ; } private SubversionRepoUUIDAndRootPath remoteUUIDAndRootPathFromCacheOrFromSVN ( Job job , SCM scm , ModuleLocation moduleLocation , String urlFromConfiguration ) throws SVNException { SubversionRepoUUIDAndRootPath uuidAndRootPath = null ; for ( Map . Entry < String , UUID > e : remoteUUIDCache . entrySet ( ) ) { String remoteRepoRootURL = e . getKey ( ) ; String remoteRepoRootURLWithSlash = remoteRepoRootURL + str ; if ( urlFromConfiguration . startsWith ( remoteRepoRootURLWithSlash ) || urlFromConfiguration . equals ( remoteRepoRootURL ) ) { UUID uuid = e . getValue ( ) ; String rootPath = SVNURL . parseURIDecoded ( e . getKey ( ) ) . getPath ( ) ; uuidAndRootPath = new SubversionRepoUUIDAndRootPath ( uuid , rootPath ) ; LOGGER . finer ( str + urlFromConfiguration + str + job ) ; break ; } } if ( uuidAndRootPath == null ) { if ( LOGGER . isLoggable ( FINER ) ) { LOGGER . finer ( str + urlFromConfiguration + str + remoteUUIDCache . keySet ( ) ) ; } UUID remoteUUID = moduleLocation . getUUID ( job , scm ) ; SVNURL repositoryRoot = moduleLocation . getRepositoryRoot ( job , scm ) ; remoteUUIDCache . put ( repositoryRoot . toString ( ) , remoteUUID ) ; uuidAndRootPath = new SubversionRepoUUIDAndRootPath ( remoteUUID , repositoryRoot . getPath ( ) ) ; } return uuidAndRootPath ; } boolean doModuleLocationHasAPathFromAffectedPath ( String configuredRepoFullPath , String rootRepoPath , Set < String > affectedPath ) { boolean containsAnAffectedPath = false ; if ( configuredRepoFullPath . startsWith ( rootRepoPath ) ) { String remainingRepoPath = configuredRepoFullPath . substring ( rootRepoPath . length ( ) ) ; if ( remainingRepoPath . startsWith ( str ) ) remainingRepoPath = remainingRepoPath . substring ( num2 ) ; String remainingRepoPathSlash = remainingRepoPath + str ; for ( String path : affectedPath ) { if ( path . equals ( remainingRepoPath ) || path . startsWith ( remainingRepoPathSlash ) || remainingRepoPath . length ( ) == num3 ) { containsAnAffectedPath = true ; break ; } } } return containsAnAffectedPath ; } private void scheduleImediatePollingOfJob ( Job job , SCMTrigger trigger , List < SvnInfo > infos ) { LOGGER . fine ( str + job ) ; final RevisionParameterAction [ ] actions ; if ( infos . isEmpty ( ) ) { actions = new RevisionParameterAction [ num3 ] ; } else { actions = new RevisionParameterAction [ ] { new RevisionParameterAction ( infos ) } ; } trigger . run ( actions ) ; } @ Override public boolean onNotify ( UUID uuid , long rev , Set < String > affectedPath ) { boolean scmFound = false , triggerFound = false , uuidFound = false , pathFound = false ; LOGGER . fine ( str ) ; for ( Job p : this . jobProvider . getAllJobs ( ) ) { SCMTriggerItem scmTriggerItem = SCMTriggerItem . SCMTriggerItems . asSCMTriggerItem ( p ) ; if ( scmTriggerItem == null ) { continue ; } if ( p instanceof AbstractProject && ( ( AbstractProject ) p ) . isDisabled ( ) ) { continue ; } String jobName = p . getName ( ) ; SCMS : for ( SCM scm : scmTriggerItem . getSCMs ( ) ) { if ( scm instanceof SubversionSCM ) scmFound = true ; else continue ; SCMTrigger trigger = scmTriggerItem . getSCMTrigger ( ) ; if ( trigger != null && ! doesIgnorePostCommitHooks ( trigger ) ) triggerFound = true ; else continue ; SubversionSCM sscm = ( SubversionSCM ) scm ; List < SvnInfo > infos = new ArrayList < SvnInfo > ( ) ; try { boolean projectMatches = false ; for ( ModuleLocation loc : sscm . getProjectLocations ( p ) ) { String urlFromConfiguration = loc . getURL ( ) ; try { SubversionRepoUUIDAndRootPath uuidAndRootPath = this . remoteUUIDAndRootPathFromCacheOrFromSVN ( p , sscm , loc , urlFromConfiguration ) ; UUID remoteUUID = uuidAndRootPath . uuid ; if ( remoteUUID . equals ( uuid ) ) uuidFound = true ; else continue ; String configuredRepoFullPath = loc . getSVNURL ( ) . getPath ( ) ; String rootRepoPath = uuidAndRootPath . rootPath ; if ( this . doModuleLocationHasAPathFromAffectedPath ( configuredRepoFullPath , rootRepoPath , affectedPath ) ) { projectMatches = true ; pathFound = true ; } if ( rev != - num2 ) { infos . add ( new SvnInfo ( loc . getURL ( ) , rev ) ) ; } } catch ( SVNCancelException e ) { LOGGER . log ( WARNING , str + urlFromConfiguration + str + jobName + str , e ) ; } catch ( SVNException e ) { LOGGER . log ( WARNING , str + urlFromConfiguration + str + jobName + str , e ) ; } if ( projectMatches ) { this . scheduleImediatePollingOfJob ( p , trigger , infos ) ; break SCMS ; } } } catch ( IOException e ) { LOGGER . log ( WARNING , str + jobName + str , e ) ; } } } LOGGER . fine ( str ) ; if ( ! scmFound ) LOGGER . warning ( str ) ; else if ( ! triggerFound ) LOGGER . warning ( str ) ; else if ( ! uuidFound ) LOGGER . warning ( str + uuid ) ; else if ( ! pathFound ) LOGGER . fine ( str ) ; return scmFound ; } } private static boolean doesIgnorePostCommitHooks ( SCMTrigger trigger ) { if ( IS_IGNORE_POST_COMMIT_HOOKS_METHOD == null ) return false ; try { return ( Boolean ) IS_IGNORE_POST_COMMIT_HOOKS_METHOD . invoke ( trigger , ( Object [ ] ) null ) ; } catch ( Exception e ) { LOGGER . log ( WARNING , str , e ) ; return false ; } } static { try { IS_IGNORE_POST_COMMIT_HOOKS_METHOD = SCMTrigger . class . getMethod ( str , ( Class [ ] ) null ) ; } catch ( Exception e ) { } } private static final Logger LOGGER = Logger . getLogger ( SubversionRepositoryStatus . class . getName ( ) ) ; } <END_VUL>
